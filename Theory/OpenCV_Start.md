# OpenCV

--- 

## Захват видео с камеры

---

Для обработки видеопотока, получаемого камерой какого-либо устройства, полезно наблюдать что "видит" это устройство и как происходит обработка.  
Для этого научимся для начала захватывать видеопоток с камеры (на примере ноутбука) средствами библиотеки OpenCV.  
OpenCV-Python — это библиотека Python, предназначенная для решения задач компьютерного зрения.

### Пошаговая инструкция

---
1. Импортируем библиотеку OpenCV.
2. Получим объект Video Capture для камеры с помощью `v2.VideoCapture()`.  
Вы можете передать индекс камеры, если к компьютеру подключено несколько камер (по умолчанию в ноутбуке индекс камеры *0* или *1*).
3. Запустим бесконечный цикл `while True:`.
4. В цикле считываем кадр из объекта захвата видео, используя его метод `read()`.
5. Показать кадр в окне с помощью `cv2.imshow()`.
6. Настраиваем выход из цикла, когда пользователь нажимает какую-либо клавишу.
7. В конце захвата видео отключаемся от камеры и закрываем все окна, созданные `cv2.imshow()`.

### Пример 1:

---
```python
import cv2 # импортируем модуль OpenCV

# захват кадров с камеры с индексом 0
cap = cv2.VideoCapture(0)

# цикл выполняется, если захват был инициализирован 
while True:
    
    # считываем кадр с камеры 
    '''
    Функция cap.read() возвращает логическое значение (True/False) и кадр.
    Если кадр был считан верно, то в ret возвращается True.
    '''
    ret, frame = cap.read() 

    # Показываем кадр
    '''
    cv2.imshow() используется для отображения видео. 
    Название окна видео будет указано в первом аргументе,
    вторым аргументом указывается кадр.
    '''
    cv2.imshow('Camera',frame) 
	
	# Выходим из цикла нажатием клавишы 'q'
    if cv2.waitKey(1) & 0xFF == ord('q'):
    	break
		
# Отключаемся от камеры
cap.release() 

# Закрываем созданные окна 
cv2.destroyAllWindows() 
```

## Наложение текста на изображение

---
При работе с оборудованием необходимо своевременно получать критическую информацию.
Для этого удобнее всего выводить информацию на экран с изображением. Средства библиотеки `opencv-python` позволяют это сделать, используя метод `cv2/putText()`.   
Метод `cv2.putText()` используется для вывода текстовой строки на любом изображении.
### Синтаксис

---
`cv2.putText(image, text, org, font, fontScale, color[, thickness[, lineType[, bottomLeftOrigin]]])`  
Параметры:
1. `image`: это изображение, на котором должен быть выведен текст.
2. `text`: текстовая строка, которую необходимо вывести.
3. `org`: это координаты нижнего левого угла текстовой строки на изображении.
Координаты представлены в виде кортежей из двух значений, то есть (значение координаты X, значение координаты Y).
4. `font`: обозначает тип шрифта. Некоторые типы шрифтов:
   1. `FONT_HERSHEY_SIMPLEX` - шрифт без засечек обычного размера (можно указать цифрой *0*)
   2. `FONT_HERSHEY_PLAIN` - шрифт без засечек небольшого размера (можно указать цифрой *1*)
   3. `FONT_HERSHEY_DUPLEX` - шрифт без засечек нормального размера (более сложный, чем `FONT_HERSHEY_SIMPLEX`) (можно указать цифрой *2*)
   4. `FONT_HERSHEY_COMPLEX` - шрифт с засечками нормального размера (можно указать цифрой *3*)
   5. `FONT_HERSHEY_TRIPLEX` - шрифт с засечками нормального размера (более сложный, чем `FONT_HERSHEY_COMPLEX`) (можно указать цифрой *4*)
   6. `FONT_HERSHEY_COMPLEX_SMALL` - уменьшенная версия `FONT_HERSHEY_COMPLEX` (можно указать цифрой *5*)
   7. `FONT_HERSHEY_SCRIPT_SIMPLEX` - шрифт в стиле рукописного ввода (можно указать цифрой *6*)
   8. `FONT_HERSHEY_SCRIPT_COMPLEX` - более сложный вариант `FONT_HERSHEY_SCRIPT_SIMPLEX` (можно указать цифрой *7*)
5. `fontScale`: коэффициент масштабирования шрифта, умноженный на базовый размер шрифта. 
6. `color`: это цвет текстовой строки, которую нужно вывести.
Для BGR мы передаем кортеж. например: (255, 0, 0) для синего цвета.
7. `thickness`: толщина линии в пикселях.

### Добавить к примеру 1:

---

```python
# Выведем на экран строку
cv2.putText(frame, "Text Information", (20, 100), 6, 3,
            (0, 255, 0), 2)
```